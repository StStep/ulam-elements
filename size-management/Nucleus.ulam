use Once;

/**
 * Nucleus is a size management element.
 * \color #f29
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element Nucleus
{
    // Types
    typedef Unsigned(6) ID;
    typedef Unsigned(4) Inst;
    typedef Unsigned(6) Dist;
    typedef CMap.Key Key;
    typedef CMap.Value Value;
    typedef EventWindow.SiteNum SiteNum;
    typedef EventWindow.Symmetry Symmetry;
    typedef SiteVisitorByType.ElementType ElementType;
    typedef WindowScanner.Category Category;

    // Utilities
    EventWindow ew;
    Random rand;

    // Model Parameters
    /** Determines the size */
    parameter Dist maxDist = 16;
    /** Determines the cycles to be stable */
    parameter Unsigned(6) stableMinCycle = 30;

    // Data members
    ID nId = 1; // Nucleus ID, unique per type
    Inst iId = 0; // Instance ID, unique per instance

    Once mOnce;
    Bool stable;
    Unsigned(6) stabCount;

    /**
     * Hard-coded color options for debugging with
     */
    ARGB getColor(Unsigned selector)
    {
        ColorUtils cu;
        ARGB ret;
        if(stable)
        {
            ret = cu.color(0xFF,0x50,0xFF);
        }
        else // unstable
        {
            ret = cu.color(0xFF,2,0x50);
        }

        return ret;
    }

    Void die()
    {
        Empty e;
        ew[0] = e;
    }

    Void spread(SiteNum site)
    {
        Cytoplasm c;
        c.nId = nId;
        c.iId = iId;
        c.dist = maxDist;
        c.instMap.empty();
        c.instMap.add((Key) iId, (Value) Value.maxof);
        ew[site] = c;
    }

    Void excite(SiteNum site, Cytoplasm c)
    {
        c.nId = nId;
        c.iId = iId;
        c.dist = maxDist;
        c.instMap.empty();
        c.instMap.add((Key) iId, (Value) Value.maxof);
        ew[site] = c;
    }

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        WindowScanner ws;
        SiteVisitorByType sv;
        AtomUtils au;
        Empty e;
        Cytoplasm c;
        Nucleus n;
        Membrane m;
        Medium me;

        typedef WindowScanner.Category Category;
        constant Category emptySI = 0;    // scan index for empties
        constant Category cytoSI = 1;   // scan index for cytoplasm
        constant Category mediumSI = 2;   // scan index for medium
        constant Category membraneSI = 3;   // scan index for membrane
        constant Category nucleusSI = 4;   // scan index for nucleus
        constant Category nonempSI = 5;     // scan index for non-empty unknowns

        ElementType emptyT = (ElementType) au.getType((Atom) e);
        ElementType cytoT = (ElementType) au.getType((Atom) c);
        ElementType mediumT = (ElementType) au.getType((Atom) me);
        ElementType membraneT = (ElementType) au.getType((Atom) m);
        ElementType nucleusT = (ElementType) au.getType((Atom) n);
        //ElementType nonempT = (ElementType) ws.cNONEMPTY_SITES_HIT; // TODO Add support for unknowns

        // Run Once
        if(mOnce.new())
        {
            iId = (Inst) rand.between(0,Inst.maxof);
        }

        sv.reset();
        sv.setType(emptySI, emptyT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(cytoSI, cytoT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(mediumSI, mediumT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(membraneSI, membraneT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(nucleusSI, nucleusT);
        ws.allocateCategory(); // TODO Put this in sv
        //sv.setType(nonempSI, nonempT);

        ws.scan(sv, 1,4);

        // Die if neighbor unknown or nucleus or membrane > 3
        if (((Unsigned) 0 != ws.getHits(nucleusSI)) || ((Unsigned) 3 < ws.getHits(membraneSI))) {
            die();
            return;
        }

        // Loop through neighbors
        Dist room[4];
        Bool safe[4];
        for(SiteNum site = 1; site <= 4; ++site)
        {
            // If Empty or Medium, spread
            Atom a = ew[site];
            if((a is Empty) || (a is Medium))
            {
                spread(site);
            }
            // If cytoplasm, excite
            else if(a is Cytoplasm)
            {
                safe[site - 1] = true;
                Cytoplasm c = (Cytoplasm) a;
                excite(site, c);
                if(site == 1)
                {
                    room[3] = c.room[3];
                }
                else if(site == 2)
                {
                    room[2] = c.room[2];
                }
                else if(site == 3)
                {
                    room[1] = c.room[1];
                }
                // Site == 4
                else
                {
                    room[0] = c.room[0];
                }
            }
            else {
                ;
            }
        }

        // Move to optimize room
        Int udDisp = ((Int) room[2]) - ((Int) room[1]);
        Int lrDisp = ((Int) room[3]) - ((Int) room[0]);

        Dist udAbs;
        if(udDisp < 0)
        {
            udAbs = (Dist) -udDisp;
        }
        else
        {
            udAbs = (Dist) udDisp;
        }

        Dist lrAbs;
        if(lrDisp < 0)
        {
            lrAbs =  (Dist) -lrDisp;
        }
        else
        {
            lrAbs = (Dist) lrDisp;
        }

        Bool isLarge = (udAbs > 2) || (lrAbs > 2);

        // Move left/right
        if(isLarge && (udAbs < lrAbs))
        {
            // Move right
            if(lrDisp > 0)
            {
                if(safe[3])
                {
                    ew.swap(0, 4);
                    return;
                }

            }
            // Move left
            else
            {
                if(safe[0])
                {
                    ew.swap(0, 1);
                    return;
                }
            }
            --stabCount;
            stable = false;
        }
        // Move up/down
        else if(isLarge)
        {
            // Move Down
            if(udDisp > 0)
            {
                if(safe[2])
                {
                    ew.swap(0, 3);
                    return;
                }
            }
            // Move Up
            else
            {
                if(safe[1])
                {
                    ew.swap(0, 2);
                    return;
                }
            }
            --stabCount;
            stable = false;
        }
        // Count stable cycles
        else
        {
            if(stabCount > stableMinCycle)
            {
                stable = true;
            }
            else
            {
                ++stabCount;
                stable = false;
            }
        }
    }
}

/**
 * Nucleus ID variation enabler
 * \color #2f2
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element NucleusB
{
    // Utilities
    EventWindow ew;

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        Nucleus n;
        n.nId = 2;
        ew[0] = n;
    }
}

/**
 * Nucleus ID variation enabler
 * \color #ff2
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element NucleusC
{
    // Utilities
    EventWindow ew;

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        Nucleus n;
        n.nId = 3;
        ew[0] = n;
    }
}
