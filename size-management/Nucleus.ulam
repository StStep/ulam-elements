use Once;

/**
 * Nucleus is a size management element.
 * \color #f29
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element Nucleus {
    // Types
    typedef Unsigned(6) ID;
    typedef Unsigned(4) Inst;
    typedef Unsigned(6) Dist;
    typedef CMap.Key Key;
    typedef CMap.Value Value;
    typedef EventWindow.SiteNum SiteNum;
    typedef EventWindow.Symmetry Symmetry;
    typedef SiteVisitorByType.ElementType ElementType;
    typedef WindowScanner.Category Category;

    // Utilities
    EventWindow ew;
    AtomUtils au;
    Random rand;

    // Model Parameters
    /** Determines the size */
    parameter Dist maxDist = 16;
    /** Determines the cycles to be stable */
    parameter Unsigned(6) stableMinCycle = 30;
    /** Determines the stability deadzone radius */
    parameter Unsigned(6) stableDeadZoneR = 4;

    // Data members
    ID nId = 1; // Nucleus ID, unique per type
    Inst iId = 0; // Instance ID, unique per instance

    Once mOnce;
    Bool stable = false;
    Dist lastRoom = 0;
    Unsigned(6) stabCount = 0;

    /**
     * Hard-coded color options for debugging with
     */
    ARGB getColor(Unsigned selector) {
        ColorUtils cu;
        ARGB ret;
        if(stable) {
            ret = cu.color(0xFF,0x50,0xFF);
        }
        else { // unstable
            ret = cu.color(0xFF,2,0x50);
        }

        return ret;
    }

    Void die() {
        Empty e;
        ew[0] = e;
    }

    Void spread(SiteNum site) {
        Cytoplasm c;
        c.nId = nId;
        c.iId = iId;
        c.dist = maxDist;
        c.instMap.empty();
        c.instMap.add((Key) iId, (Value) Value.maxof);
        ew[site] = c;
    }

    Void excite(SiteNum site, Cytoplasm c) {
        c.nId = nId;
        c.iId = iId;
        c.dist = maxDist;
        c.instMap.empty();
        c.instMap.add((Key) iId, (Value) Value.maxof);
        ew[site] = c;
    }

    /**
     * Primary runtime logic
     */
    Void behave() {
        WindowScanner ws;
        SiteVisitorByType sv; // TODO Make cyto focused class, can do more with it, less boilerplate
        Empty e;
        Cytoplasm c;
        Nucleus n;
        Membrane m;
        Medium me;

        typedef WindowScanner.Category Category;
        constant Category emptySI = 0;    // scan index for empties
        constant Category cytoSI = 1;   // scan index for cytoplasm
        constant Category mediumSI = 2;   // scan index for medium
        constant Category membraneSI = 3;   // scan index for membrane
        constant Category nucleusSI = 4;   // scan index for nucleus
        constant Category nonempSI = 5;     // scan index for non-empty unknowns

        ElementType emptyT = (ElementType) au.getType((Atom) e);
        ElementType cytoT = (ElementType) au.getType((Atom) c);
        ElementType mediumT = (ElementType) au.getType((Atom) me);
        ElementType membraneT = (ElementType) au.getType((Atom) m);
        ElementType nucleusT = (ElementType) au.getType((Atom) n);
        //ElementType nonempT = (ElementType) ws.cNONEMPTY_SITES_HIT; // TODO Add support for unknowns

        // Run Once
        if(mOnce.new()) {
            iId = (Inst) rand.between(0,Inst.maxof);
        }

        sv.reset();
        sv.setType(emptySI, emptyT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(cytoSI, cytoT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(mediumSI, mediumT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(membraneSI, membraneT);
        ws.allocateCategory(); // TODO Put this in sv
        sv.setType(nucleusSI, nucleusT);
        ws.allocateCategory(); // TODO Put this in sv
        //sv.setType(nonempSI, nonempT);

        ws.scan(sv, 1, 1);

        // Die if neighbor nucleus or membrane > 3
        // TODO add unknown death
        if (((Unsigned) 0 != ws.getHits(nucleusSI)) || ((Unsigned) 3 < ws.getHits(membraneSI))) {
            die();
            return;
        }

        // Spread to empty TODO Add Medium
        if((Unsigned) 0 != ws.getHits(emptySI)) {
            spread(ws.getSiteNum(emptySI));
        }

        // Excite Cytoplasm and check room
        Dist roomDiff = 0;
        SiteNum site;
        if((Unsigned) 0 != ws.getHits(cytoSI)) {
            site = ws.getSiteNum(cytoSI);
            Cytoplasm c = (Cytoplasm) ew[site];
            Dist room = c.room;

            if(lastRoom > room) {
                roomDiff = (Dist) (lastRoom - room);
            }
            lastRoom = room;
            excite(site, c);
        }

        // Move
        if(roomDiff > stableDeadZoneR ) {
            --stabCount;
            stable = false;
            ew.swap(0, site);
            return;
        }
        // Else count stable cycles
        else {
            if(stabCount > stableMinCycle) {
                stable = true;
            }
            else {
                ++stabCount;
                stable = false;
            }
        }
    }
}

/**
 * Nucleus ID variation enabler
 * \color #2f2
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element NucleusB {
    // Utilities
    EventWindow ew;

    /**
     * Primary runtime logic
     */
    Void behave() {
        Nucleus n;
        n.nId = 2;
        ew[0] = n;
    }
}

/**
 * Nucleus ID variation enabler
 * \color #ff2
 * \symbol Nu
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 * \license lgpl
 */
element NucleusC {
    // Utilities
    EventWindow ew;

    /**
     * Primary runtime logic
     */
    Void behave() {
        Nucleus n;
        n.nId = 3;
        ew[0] = n;
    }
}
