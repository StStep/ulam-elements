/**
 * Medium is a routing element
 * \color #22f
 * \symbol Me
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 *
 * \license lgpl
 *
 */

element Medium
{
    // Types
    typedef Map.Key Key;
    typedef Map.Value Dist;
    typedef EventWindow.SiteNum SiteNum;
    typedef MoltChild.State State;

    constant State dead = 2;

    // Utilities
    EventWindow ew;

    // Data members
    Map distMap;

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        // Setup temp map
        Map tmpMap = distMap;

        // Loop through neighbors
        WindowServices ws;
        ws.reset(1,1);
        for(Int slot = ws.next(); slot >= 0; slot = ws.next())
        {
            // If Medium neigbor, calc max dist for distMap
            Atom a = ew[(SiteNum) slot];
            if(a is Medium)
            {
                Medium neig = (Medium) a;
                tmpMap.setMax(neig.distMap);
            }
            // If Dead Molt, propogate
            else if(a is MoltChild)
            {
                MoltChild child = (MoltChild) a;
                if(child.state == dead)
                {
                    Medium m;
                    ew[(SiteNum) slot] = m;
                }
            }
            // If empty, make barrier
            else if(a is Empty)
            {
                Barrier b;
                ew[(SiteNum) slot] = b;
            }
            else if(a is Barrier)
            {
                // Do nothing
            }
            // Else become barriar if unknown
            else
            {
                Barrier b;
                ew[0] = b;
            }
        }

        // Decay all, either prev or max from neighbor
        tmpMap.modify(-1);
        distMap = tmpMap;
    }
}
