/**
 * Molt is a size management element.
 * \color #f22
 * \symbol Mo
 * \symmetries normal
 *
 * \author R. Stephens Summerlin
 *
 * \license lgpl
 *
 */

element Molt
{
    // Types
    typedef EventWindow.SiteNum SiteNum;
    typedef Unsigned(2) State;
    typedef Unsigned(6) Gen;

    // Utilities
    EventWindow ew;

    // Constants
    constant State inactive = 0;
    constant State active = 1;
    constant State dead = 3;

    // Model Parameters
    /**
     * Determines the size
     */
    parameter Gen maxGen = 8;

    // Data members
    State state;
    Gen curGen;

    /**
     * Copy self, incerementing generation and resetting state
     */
    Molt propogate()
    {
        Molt m = self;
        ++m.curGen;
        m.state = inactive;
        return m;
    }

    /**
     * Handle inactive state.
     *
     * Do nothing until no adjacent active molts, then become active.
     */
    State tInactive()
    {
        // Loop through neighbors
        WindowServices ws;
        ws.reset(1,1);
        Bool alone = true;
        for(Int slot = ws.next(); slot >= 0; slot = ws.next())
        {
            Atom a = ew[(SiteNum) slot];
            if(a is Molt)
            {
                Molt mlt = (Molt) a;
                if(mlt.state == active)
                {
                    alone = false;
                }

            }
        }

        if(alone)
            return active;
        else
            return inactive;
    }

    /**
     * Handle active state.
     *
     * Copy self into each adjacent space and then die
     */
    State tActive()
    {
        if(curGen >= maxGen)
        {
            return dead;
        }
        // Loop through neighbors
        WindowServices ws;
        ws.reset(1,1);
        for(Int slot = ws.next(); slot >= 0; slot = ws.next())
        {
            Atom a = ew[(SiteNum) slot];
            if(a is Empty)
            {
                ew[(SiteNum) slot] = propogate();
            }
        }

        return dead;
    }

    /**
     * Handle dead state.
     *
     * Stay dead.
     */
    State tDead()
    {
        return dead;
    }

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        // Loop through neighbors
        State next = state;
        if(state == inactive)
        {
            next = tInactive();
        }
        else if(state == active)
        {
            next = tActive();
        }
        // Else dead
        else
        {
            next = tDead();
        }
        state = next;
    }
}
