/**
  Medium is a routing element
  \color #22f
  \symbol Me
  \symmetries normal

  \author R. Stephens Summerlin

  \license lgpl
*/

element Medium
{
    // Implementation Attributes
    constant Unsigned k = 4;
    constant Unsigned v = 6;
    constant Unsigned n = 7;

    // Types
    typedef Unsigned(k) Key;
    typedef Unsigned(v) Dist;
    typedef Key Keys[n];
    typedef Dist Dists[n];
    typedef EventWindow.SiteNum SiteNum;

    // Utilities
    EventWindow ew;

    // Data members
    Keys mKeys;
    Dists mDists;

    /**
     * Add key-value pair to dictionary, using one of the following, in order:
     *  (1) If key already exists, update it
     *  (2) If not the dict is not full, add a new key
     *  (3) If full, replace the smallest key-value it is larger than, if any
     */
    Void addDistEntry(Key key, Dist dist)
    {
        Int matchInd = -1;
        Int emptyInd = -1;
        Int smallerInd = -1;
        Dist ldist = dist;
        for(Int i; i < n; ++i)
        {
            // If match found
            if(key == mKeys[i])
            {
                matchInd = i;
                break;
            }
            // Elif Empty
            else if((emptyInd < 0) && (mKeys[i] == 0))
            {
                emptyInd = i;
            }
            // Else non-matching key
            else
            {
                if(mDists[i] < ldist)
                {
                    smallerInd = i;
                    ldist = mDists[i];
                }
            }
        }

        // If match found
        if(matchInd >= 0)
        {
            mKeys[matchInd] = key;
            mDists[matchInd] = dist;
        }
        // Elif Not Full
        else if(emptyInd >= 0)
        {
            mKeys[emptyInd] = key;
            mDists[emptyInd] = dist;
        }
        // Elif Full, but smaller entry exists
        else if(smallerInd >= 0)
        {
            mKeys[smallerInd] = key;
            mDists[smallerInd] = dist;
        }
        // Else Full, and smaller than any existing entry
        else
        {
            // Do nothing
        }
    }

    /**
     * Get the value for a given key, a value of 0 is returned when no key is found
     */
    Dist getEntry(Key key)
    {
        Dist ret = 0;
        for(Int i; i < n; ++i)
        {
            // If match found
            if(key == mKeys[i])
            {
                ret = mDists[i];
                break;
            }
        }

        return ret;
    }

    /**
     * Primary runtime logic
     */
    Void behave()
    {
        // Setup Distance variables
        Dist mdist = mDists[0];
        Dist ldist = 0;
        if(mDists[0] > 1)
        {
            ldist = (Dist) (mDists[0] -1);
        }

        // Create child to copy
        Medium m;
        m.mDists[0] = ldist;

        // Loop through neighbors
        WindowServices ws;
        ws.reset(1,1);
        for(Int slot = ws.next(); slot >= 0; slot = ws.next())
        {
            // Set mdist to largest neig.mDists[0] - 1
            Atom a = ew[(SiteNum) slot];
            if(a is Medium)
            {
                Medium neig = (Medium) a;
                if(neig.mDists[0] > mdist)
                {
                    mdist = (Dist) (neig.mDists[0] - 1);
                }
            }
            // Propogate to empty
            else if(a is Empty)
            {
                ew[(SiteNum) slot] = m;

            }
            else
            {
                // Do nothing
            }
        }

        // If found larger mDists[0], set to larger, otherwise decay
        if(mdist > mDists[0])
        {
            mDists[0] = mdist;
        }
        else
        {
            mDists[0] = ldist;
        }
    }
}
